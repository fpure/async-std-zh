<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Futures - 使用 async-std 在 Rust 中进行异步编程</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Async programming in Rust with async-std">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="../introduction.zh.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><ol class="section"><li class="expanded "><a href="../overview/async-std.zh.html"><strong aria-hidden="true">1.1.</strong> 欢迎来到async-std！</a></li><li class="expanded "><a href="../overview/std-and-library-futures.zh.html"><strong aria-hidden="true">1.2.</strong> std::future和futures-rs</a></li><li class="expanded "><a href="../overview/stability-guarantees.zh.html"><strong aria-hidden="true">1.3.</strong> 稳定性保证</a></li></ol></li><li class="expanded "><a href="../concepts.zh.html"><strong aria-hidden="true">2.</strong> 使用 async-std 的异步概念</a></li><li><ol class="section"><li class="expanded "><a href="../concepts/futures.zh.html" class="active"><strong aria-hidden="true">2.1.</strong> Futures</a></li><li class="expanded "><a href="../concepts/tasks.zh.html"><strong aria-hidden="true">2.2.</strong> Tasks</a></li><li class="expanded "><a href="../concepts/async-read-write.zh.html"><strong aria-hidden="true">2.3.</strong> TODO：异步读/写</a></li><li class="expanded "><a href="../concepts/streams.zh.html"><strong aria-hidden="true">2.4.</strong> TODO：Streams and Channels</a></li></ol></li><li class="expanded "><a href="../tutorial/index.zh.html"><strong aria-hidden="true">3.</strong> 教程：实现聊天</a></li><li><ol class="section"><li class="expanded "><a href="../tutorial/specification.zh.html"><strong aria-hidden="true">3.1.</strong> 规格和入门</a></li><li class="expanded "><a href="../tutorial/accept_loop.zh.html"><strong aria-hidden="true">3.2.</strong> 编写一个 Accept 循环</a></li><li class="expanded "><a href="../tutorial/receiving_messages.zh.html"><strong aria-hidden="true">3.3.</strong> 接收讯息</a></li><li class="expanded "><a href="../tutorial/sending_messages.zh.html"><strong aria-hidden="true">3.4.</strong> 发送讯息</a></li><li class="expanded "><a href="../tutorial/connecting_readers_and_writers.zh.html"><strong aria-hidden="true">3.5.</strong> 连接读者和作家</a></li><li class="expanded "><a href="../tutorial/all_together.zh.html"><strong aria-hidden="true">3.6.</strong> 全部一起来</a></li><li class="expanded "><a href="../tutorial/clean_shutdown.zh.html"><strong aria-hidden="true">3.7.</strong> 干净地关机</a></li><li class="expanded "><a href="../tutorial/handling_disconnection.zh.html"><strong aria-hidden="true">3.8.</strong> 处理断开连接</a></li><li class="expanded "><a href="../tutorial/implementing_a_client.zh.html"><strong aria-hidden="true">3.9.</strong> 实现一个 Client</a></li></ol></li><li class="expanded "><a href="../patterns.zh.html"><strong aria-hidden="true">4.</strong> TODO：异步模式</a></li><li><ol class="section"><li class="expanded "><a href="../patterns/small-patterns.zh.html"><strong aria-hidden="true">4.1.</strong> TODO：收集的小模式</a></li></ol></li><li class="expanded "><a href="../security/index.zh.html"><strong aria-hidden="true">5.</strong> 安全实践</a></li><li><ol class="section"><li class="expanded "><a href="../security/policy.zh.html"><strong aria-hidden="true">5.1.</strong> 安全披露和政策</a></li></ol></li><li class="expanded "><a href="../glossary.zh.html"><strong aria-hidden="true">6.</strong> 术语</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">使用 async-std 在 Rust 中进行异步编程</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#futures" id="futures">Futures</a></h1>
<p>关于 Rust 的值得注意的一点是<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html"><em>无畏并发</em></a>。这就是应该授权您在不放弃安全性的情况下，执行并发任务的思考。同样，Rust 作为一种低级语言，它的无畏并发中，<em>没有选择具体的实现策略</em>。这意味着，我们<em>必须</em>对策略进行抽象，以允许<em>后来</em>选择(给用户发挥的空间)，如果我们想以某种方式，在不同策略的用户之间共享代码，这又怎么搞。</p>
<p>Future 从*计算(computation)*抽象出来。描述了“什么(what)”，与“哪里(where)”和“何时(when)”无关。为此，他们的目标是将代码分解为可组合的小行动，然后由我们系统的一部分执行。让我们来趟旅程，计算下东西，找找可以抽象的地方，理解它的含义。</p>
<h2><a class="header" href="#send-and-sync" id="send-and-sync">Send and Sync</a></h2>
<p>幸运的是，并发 Rust 已经有两个众所周知的有效概念，它们抽象了程序并发部分之间的共享：<code>Send</code>和<code>Sync</code>。值得注意的是，<code>Send</code>和<code>Sync</code> trait 抽象的<em>策略</em>，包括并发工作，组成整齐，并且不实际实现。</p>
<p>快速摘要：</p>
<ul>
<li>
<p><code>Send</code>抽象了，在一个计算中，<em>将数据传递</em>，到另一个并发计算（让我们称其为接收方-receiver），而在发送方则失去对它的访问。在许多编程语言中，通常都采用这种策略，但是缺少语言方面的支持，因此希望您自己遵循“丢失访问”行为。这是漏洞的常规来源：发件人保留发送内容的控制权，甚至在发送后也去使用它们。Rust 通过将这种行为定为’已知’，来减轻此问题。类型可以为是/非<code>Send</code>（通过实现适当的标记 trait），能/不允许将它们发送出去，而所有权和借用规则会对后续访问进行控制(阻止与否)。</p>
</li>
<li>
<p><code>Sync</code>关于<em>共享数据</em>，处在程序的两个并发部分之间。这是另一种常见的模式：由于写入内存位置，或在另一方正在写入时，就进行读取，在本质上是不安全的，因此需要通过同步(sync)来缓和这种访问。<sup class="footnote-reference"><a href="#1">1</a></sup>这里有许多常见方式，针对双方共识，即不要同时使用内存中的同一部分，例如互斥锁和自旋锁（mutexes and spinlocks）。同样，Rust 为您提供了省心的（安全！）选项。Rust 使您能够表达某些<em>需要</em>同步的东西，但不用具体说明<em>怎么样</em>去做的。</p>
</li>
</ul>
<p>注意我们避免出现类似 <em>“线程(thread)”</em>，而是选择了“计算(computation)”。<code>Send</code>和<code>Sync</code>的威力是，减轻了您对“<em>什么</em>是共享”的学习负担。在实现时，您只需要知道哪种共享方法，是适用于当前类型的。这保持了本地化的合理，不受该类型用户，以后会使用的任何实现的影响。</p>
<p><code>Send</code>和<code>Sync</code>可以以有趣的方式进行合成，但这超出了本文的范围。您可以在<a href="https://doc.rust-lang.org/stable/book/ch16-04-extensible-concurrency-sync-and-send.html">Rust Book</a>找到示例。</p>
<p>总结：Rust 使我们能够安全地抽象并发程序的重要属性，及其数据共享。它以非常轻巧的方式进行。语言本身只知道两个标记<code>Send</code>和<code>Sync</code>，并尽可能地通过派生它们本身来帮助我们。剩下的就是图书馆的问题。</p>
<h2><a class="header" href="#an-easy-view-of-computation" id="an-easy-view-of-computation">An easy view of computation</a></h2>
<p>虽然 computation 作为一个主题，可以写出一整本<a href="https://computationbook.com/">book</a>出来，但一个非常简化的视图对我们来说，就足够了：一系列可组合的操作，这些操作可以基于决策进行分支，相继执行，并产生（yield）结果或产生（yield）错误</p>
<h2><a class="header" href="#deferring-computation" id="deferring-computation">Deferring computation</a></h2>
<p>正如刚才提到的，<code>Send</code>和<code>Sync</code>是关于数据的。但是程序不仅涉及数据，还涉及对数据<em>进行计算</em>。这就是<a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Futures</code></a>所要做的。在下一章中，我们将仔细研究它的工作方式。让我们用英语，看看 Future 允许我们表达什么。Future 的计划，是（将正常的计算流程）从：</p>
<ul>
<li>做 X</li>
<li>如果 X 成功，则执行 Y</li>
</ul>
<p>转向(这个流程)：</p>
<ul>
<li>开始做 X</li>
<li>一旦 X 成功，就开始做 Y</li>
</ul>
<pre><code>- Do X
- If X succeeded, do Y

towards:

- Start doing X
- Once X succeeds, start doing Y
</code></pre>
<p>还记得前言中，有关“延迟计算”的话题吗？这就是所有的要点。不再<em>立即</em>告诉计算机执行什么，以及下一个决定，我们改成了，告诉它要开始做什么，以及如何对潜在事件做出反应 ... well 也就是 ... <code>Future</code>。</p>
<h2><a class="header" href="#orienting-towards-the-beginning" id="orienting-towards-the-beginning">Orienting towards the beginning</a></h2>
<p>让我们看一个简单的函数，特别是返回值：</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{fs::File, io, io::prelude::*};
</span><span class="boring">
</span>fn read_file(path: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}
<span class="boring">}
</span></code></pre></pre>
<p>您可以随时调用它，因此可以完全控制何时调用它。但这也是问题所在：调用它的那一刻，控制权就转移到被调用的函数，直到它最终返回一个值。请注意，此返回值来自过去(得出值的那一刻)。过去有一个缺点：已经做出了所有决定。它有一个优点：结果是可见。我们可以解开程序过去的计算结果，然后决定如何处理它。</p>
<p>但是，我们想对<em>computation</em>进行抽象，并让其他人选择运行方式。从根本上说，这与一直查看先前的计算结果不兼容。所以，让我们找到一个类型来<em>描述</em>，一个不执行的 computation。让我们再次看一下函数：</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{fs::File, io, io::prelude::*};
</span><span class="boring">
</span>fn read_file(path: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}
<span class="boring">}
</span></code></pre></pre>
<p>说到时机，我们只能在调用函数<em>之前</em>或函数返回<em>之后</em>采取行动。而这是不可取的，因为它拿走了，<em>处于</em>运行中，帮我们做某事的能力。当与并行代码配合时，会拿走我们在首次运行时，启动并行任务的能力（因为我们放弃了控制权）。</p>
<p>这时，是祭出<a href="https://en.wikipedia.org/wiki/Thread_">threads</a>的时候了。但是 threads 是一个非常特定的并发原语，且我们说过我们正在寻找一个抽象。</p>
<p>我们正在寻找的东西，要能在 future 中，代表正在进行的工作，和朝向一个 result。每当我们在 Rust 语言中，说“something”时，基本可表示为一种 trait。那就让我们从一个不完整的<code>Future</code> trait 定义开始吧：</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{pin::Pin, task::{Context, Poll}};
</span><span class="boring">
</span>trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>仔细观察，我们看到以下内容：</p>
<ul>
<li>它是泛型的<code>Output</code>。</li>
<li>它提供了一个称为<code>poll</code>的函数，这使我们可以检查/推进当前 computation 的状态。</li>
<li>（目前忽视<code>Pin</code>和<code>Context</code>，深入理解该 trait 之前，暂时不需要这些。）</li>
</ul>
<p>每次调用<code>poll()</code>可能导致以下两种情况之一：</p>
<ol>
<li>computation 完成，<code>poll</code>将返回<a href="https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a></li>
<li>computation 尚未完成执行，它将返回<a href="https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Pending"><code>Poll::Pending</code></a></li>
</ol>
<p>这使我们可以从外部检查，<code>Future</code>是否仍有未完成的工作，或者最终是完成了，可以给我们带来值。最简单（但效率不高）的方法是，在一个循环中，不断轮询(poll) Future。这有优化的可能性，好的 runtime 会帮你搞定。请注意，情况 1 发生后，再次<code>poll</code>可能会导致行为混乱。参考<a href="https://doc.rust-lang.org/std/future/trait.Future.html">futures-docs</a>中的有关详细信息。</p>
<h2><a class="header" href="#async" id="async">Async</a></h2>
<p>而<code>Future</code> trait 在 Rust 中已经存在了一段时间，构建和描述它们都很不方便。为此，Rust 现在具有特殊的语法：<code>async</code>。上面的示例，使用<code>async-std</code>，如下所示：</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_std;
</span><span class="boring">use async_std::{fs::File, io, io::prelude::*};
</span><span class="boring">
</span>async fn read_file(path: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).await?;
    Ok(contents)
}
<span class="boring">}
</span></code></pre></pre>
<p>差别很小，对吧？我们要做的只是将函数标记上<code>async</code>，并插入 2 个特殊命令：<code>.await</code>。</p>
<p>这个<code>async</code>函数设置了一个延迟计算。调用此函数时，将产生一个<code>Future&lt;Output = io::Result&lt;String&gt;&gt;</code>，而不是立即返回<code>io::Result&lt;String&gt;</code>。（或者，更准确地说，为您生成一个类型，而这个类型实现了<code>Future&lt;Output = io::Result&lt;String&gt;&gt;</code>）</p>
<h2><a class="header" href="#what-does-await-do" id="what-does-await-do">What does <code>.await</code> do?</a></h2>
<p><code>.await</code>后缀，它的作用与其名字完全一样：在您使用它的那一刻，代码将一直等到所请求的操作（例如，打开文件或读取其中的所有数据）完成。<code>.await?</code>并不特殊，只是应用<code>?</code>操作符，整出了<code>.await</code>这个结果。那么，我们从初始代码示例中，又获得了什么？我们正在获取 Future，然后立即等待它们？</p>
<p>把<code>.await</code>行为称作一个 marker。在这里，代码会等待<code>Future</code>产生其价值。那 Future 又是如何驶向完成的呢？这你不用管了，marker 会允许组件（通常为“runtime”）负责<em>executing</em>这段代码，且当这个 computation 部分完成时，必须执行的所有其他操作。当后台执行操作的完成后，会回到这 marker 的代码位置。这就是为什么，这种编程风格也被称为<em>事件编程(evented programming)</em>。我们在等<em>事情的发生</em>（例如要打开的文件），然后做出反应（如开始读取）。</p>
<p>当同时执行两个或多个这些函数时，我们的运行时系统便可以通过处理目前正在进行的<em>所有其他事件</em>，来填充等待时间。</p>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>来到 value（值） 的方面，我们寻找能够表达<em>一直工作，就能获得稍后可用的值</em>。从那里，我们会讨论了轮询(poll)的概念。</p>
<p><code>Future</code>作为一种任意数据类型，且并不代表一个值，但具有<em>在将来的某个时刻产生值</em>的能力。根据用例，这种实现的方式千差万别，但接口简单。</p>
<p>接下来，我们将向您介绍<code>tasks</code>，实际使用<em>run</em> Future。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Two parties reading while it is guaranteed that no one is writing is always safe.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../concepts.zh.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../concepts/tasks.zh.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../concepts.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../concepts/tasks.zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-128555056-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../custom.js"></script>
        

        

    </body>
</html>
